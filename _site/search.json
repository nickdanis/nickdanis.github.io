[
  {
    "objectID": "teaching.html",
    "href": "teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "My office hours this semester are Fridays 10-11am in January 206. Syllabi for the current semester can be accessed below:\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "teaching.html#spring-2026",
    "href": "teaching.html#spring-2026",
    "title": "Teaching",
    "section": "",
    "text": "My office hours this semester are Fridays 10-11am in January 206. Syllabi for the current semester can be accessed below:\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\n\n\n\n\n\n\n2026 Spring\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "teaching.html#archive",
    "href": "teaching.html#archive",
    "title": "Teaching",
    "section": "Archive",
    "text": "Archive\nAll of my previous syllabi since 2019 are archived below. Note that all courses were renumbered university-wide starting with the Fall 2025 semester.\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Semester\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\n\nTitle\n\n\n\nSemester\n\n\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2019 Fall\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2020 Fall\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2021 Fall\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2024 Fall\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2023 Spring\n\n\n\n\n\n\nLING 148 The Linguistics of Constructed Languages\n\n\n2024 Spring\n\n\n\n\n\n\nLING 1600 Introduction to Linguistics\n\n\n2026 Spring\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2019 Fall\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2020 Fall\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2022 Fall\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2023 Fall\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2019 Spring\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2021 Spring\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2023 Spring\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2024 Spring\n\n\n\n\n\n\nLING 170D Introduction to Linguistics\n\n\n2025 Spring\n\n\n\n\n\n\nLING 258 Methods in Linguistic Research\n\n\n2024 Fall\n\n\n\n\n\n\nLING 312 Phonetics\n\n\n2019 Spring\n\n\n\n\n\n\nLING 312 Phonetics\n\n\n2020 Spring\n\n\n\n\n\n\nLING 313 Phonological Analysis\n\n\n2019 Fall\n\n\n\n\n\n\nLING 313 Phonological Analysis\n\n\n2020 Fall\n\n\n\n\n\n\nLING 313 Phonological Analysis\n\n\n2021 Fall\n\n\n\n\n\n\nLING 313 Phonological Analysis\n\n\n2022 Fall\n\n\n\n\n\n\nLING 313 Phonological Analysis\n\n\n2024 Fall\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2019 Spring\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2020 Spring\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2021 Spring\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2023 Spring\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2024 Spring\n\n\n\n\n\n\nLING 317 Introduction to Computational Linguistics\n\n\n2025 Spring\n\n\n\n\n\n\nLING 3250 Introduction to Computational Linguistics\n\n\n2026 Spring\n\n\n\n\n\n\nLING 4250 Computation and Learnability in Linguistic Theory\n\n\n2026 Spring\n\n\n\n\n\n\nLING 427 Computation and Learnability in Linguistic Theory\n\n\n2021 Fall\n\n\n\n\n\n\nLING 427 Computation and Learnability in Linguistic Theory\n\n\n2022 Fall\n\n\n\n\n\n\nLING 427 Computation and Learnability in Linguistic Theory\n\n\n2020 Spring\n\n\n\n\n\n\nLING 495 Senior Seminar in Optimality Theory\n\n\n2023 Fall\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "syllabi/ling427-sp2020-syllabus.html",
    "href": "syllabi/ling427-sp2020-syllabus.html",
    "title": "LING 427 Computation and Learnability in Linguistic Theory",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling427-fa2021-syllabus.html",
    "href": "syllabi/ling427-fa2021-syllabus.html",
    "title": "LING 427 Computation and Learnability in Linguistic Theory",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling3250-sp2026-syllabus.html",
    "href": "syllabi/ling3250-sp2026-syllabus.html",
    "title": "LING 3250 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2024-syllabus.html",
    "href": "syllabi/ling317-sp2024-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2021-syllabus.html",
    "href": "syllabi/ling317-sp2021-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2019-syllabus.html",
    "href": "syllabi/ling317-sp2019-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling313-fa2022-syllabus.html",
    "href": "syllabi/ling313-fa2022-syllabus.html",
    "title": "LING 313 Phonological Analysis",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling313-fa2020-syllabus.html",
    "href": "syllabi/ling313-fa2020-syllabus.html",
    "title": "LING 313 Phonological Analysis",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling312-sp2020-syllabus.html",
    "href": "syllabi/ling312-sp2020-syllabus.html",
    "title": "LING 312 Phonetics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling258-fa2024-syllabus.html",
    "href": "syllabi/ling258-fa2024-syllabus.html",
    "title": "LING 258 Methods in Linguistic Research",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-sp2024-syllabus.html",
    "href": "syllabi/ling170d-sp2024-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-sp2021-syllabus.html",
    "href": "syllabi/ling170d-sp2021-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-fa2023-syllabus.html",
    "href": "syllabi/ling170d-fa2023-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-fa2020-syllabus.html",
    "href": "syllabi/ling170d-fa2020-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling1600-sp2026-syllabus.html",
    "href": "syllabi/ling1600-sp2026-syllabus.html",
    "title": "LING 1600 Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling148-sp2023-syllabus.html",
    "href": "syllabi/ling148-sp2023-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling148-fa2021-syllabus.html",
    "href": "syllabi/ling148-fa2021-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling148-fa2019-syllabus.html",
    "href": "syllabi/ling148-fa2019-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "publications.html",
    "href": "publications.html",
    "title": "Publications",
    "section": "",
    "text": "Jardine, Adam, Nick Danis, and Luca Iacoponi. 2021. A formal investigation of Q-Theory in comparison to Autosegmental Representations. Linguistic Inquiry 52.2. [doi, lingbuzz]\nDanis, Nick. 2020. Yoruba vowel deletion involves compensatory lengthening: evidence from phonetics. Stellenbosch Papers in Linguistics Plus 60. [doi]\nDanis, Nick. 2019. Long-distance major place harmony. Phonology 36.4. 573-604. [doi, lingbuzz, ROA-1365]\n\n\n\n\n\nAkinlabi, Akinbiyi and Nick Danis. In press. “Nonlinear representations.” To appear in Adam Jardine and Paul de Lacy (eds.), The Cambridge Handbook of Phonology, 2nd edition.\n\n\n\n\n\nDanis, Nick. 2025. “Logical transductions are not sufficient for notational equivalence,” In Gérard Avelino, Merlin Balihaxi, Quartz Colvin, Vincent Czarnecki, Hyunjung Joo, Chenli Wang, Utku Zobarlar, Adam Jardine and Adam McCollum (eds.), Proceedings of the 2023 and 2024 Annual Meetings on Phonology (Supplemental). [doi]\nDanis, Nick and Adam Jardine. 2019. “Q-Theory Representations are Logically Equivalent to Autosegmental Representations,” Proceedings of the Society for Computation in Linguistics: Vol. 2 , Article 5. [doi]\nDanis, Nick. 2017. Major place harmony in ABC and the (reduced) role of representation: evidence from Ngbaka. In Karen Jesney, Charlie O’Hara, Caitlin Smith and Rachel Walker (eds.), Proceedings of the 2016 Annual Meeting on Phonology. Washington, DC: Linguistic Society of America. [doi, lingbuzz, ROA-1302]\nDanis, Nick. 2017. Markedness and Complex Stops: Evidence from Simplification Processes. In Shigeki Kaji (ed.), Proceedings of the 8th World Congress of African Languages Kyoto 2015, 25–43. Tokyo University of Foreign Studies: Research Institute for Languages and Cultures of Asia and Africa. [ROA-1303]\nDanis, Nick, Jonathan Barnes, and Catherine O’Connor. 2012. Downstep and Contour Formation in Medumba: A Prosodic Account. In Michael R. Marlo, Nikki B. Adams, Christopher R. Green, Michelle Morrison, and Tristan M. Purvis (eds.), Selected Proceedings of the 42nd Annual Conference on African Linguistics. Somerville, MA: Cascadilla Proceedings Project, pp. 22-31. [PDF]\n\n\n\n\n\nDanis, Nick. 2017. Complex place and place identity. PhD Dissertation, Rutgers University. Chair: Akin Akinlabi. [doi, lingbuzz, ROA-1324]\nDanis, Nick. 2014. Deriving Interactions of Complex Stops. Ms., Rutgers University. Second Qualifying Paper. Committee: Alan Prince (Chair), Bruce Tesar, Akin Akinlabi. [ROA-1220, ROA-1221 (OTWorkplace Supplement)]\nDanis, Nick. 2011. The Phonological Word in Medumba. Ms., Boston University. Master’s project.\n\n\n\n\n\nDanis, Nick, Kate Mesh, and Hyunsuk Sung (eds.). 2011. Proceedings of the 35th Annual Conference on Language Development. Somerville, MA: Cascadilla Press.\n\n\n\n\n\n\n\nDanis, Nick. 2026. Representing phonology in the formal comparison of phonological representations. Keynote speaker, Workshop on The Role of Representation in Computational Phonology. OCP23 satellite workshop. University of Cambridge, January 13, 2026.\nDanis, Nick. 2024. Comparing representations: Towards a strong generative capacity for phonology. Invited speaker, RULing 2024, Rutgers University, May 3, 2024. [python supplement]\nDanis, Nick. 2023. Comparing representations: Towards a strong generative capacity for phonology. Invited colloquium, GSAS Circles Talk, Harvard University, February 17, 2023.\nDanis, Nick. 2022. Comparing phonological representations. Invited keynote, Graduate Linguistics Expo at Michigan State (GLEAMS) 2022. Michigan State University, October 28-29, 2022.\n\n\n\n\n\nDanis, Nick. 2022. Natural class-preserving transductions among phonological representations. Workshop on Model-Theoretic Representations in Phonology. Stony Brook University, September 22-24, 2022.\nDanis, Nick and Adam Jardine. 2019. Q-Theory Representations are logically equivalent to Autosegmental Representations. SCiL, co-meeting with the LSA 2019.\nDanis, Nick. 2016. Major place harmony and the (reduced) role of representation: Evidence from Ngbaka. AMP 2016. USC. October 21-23, 2016.\nDanis, Nick. 2016. Cross-category vowel-consonant interactions in Aghem and Vietnamese. Presented at the University of Chicago Phonology Group, May 13, 2016.\nDanis, Nick. 2015. Markedness and Complex Segments: Evidence from Simplification Processes. 8th World Congress of African Linguistics. Presented Talk. Kyoto University. August 21, 2015.\nDanis, Nick. 2015. A Typology of Complex Segments: Multiple Place Interactions on a Scale. Workshop on Formal Typologies. Rutgers University, May 30, 2015.\nDanis, Nick. 2015. Complex Segments Made Simple: Markedness and Doubly-Articulated Stops. 46th Annual Conference on African Linguistics. Presented Talk. University of Oregon. March 27, 2015.\nDanis, Nick, Jonathan Barnes, and Catherine O’Connor. 2011. Downstep and Contour Formation in Medumba: A Grassfields Bantu Language. 42th Annual Conference on African Linguistics. Presented Talk. University of Maryland.\n\n\n\n\n\nDanis, Nick. 2024. Logical transductions are not sufficient for notational equivalence. Poster presented at the Annual Meeting on Phonology (AMP) 2024. Rutgers University, November 1-3, 2024.\nDanis, Nick. 2024. Logical transductions are not sufficient for notational equivalence. Poster presented at the 29th Mid-Continental Phonetics and Phonology Conference (MidPhon 29). University of Illinois at Urbana-Champaign, October 4–5, 2024. (See AMP 2024 link for poster PDF.)\nDanis, Nick. 2020. Phonology needs geometry: Implicit axioms in segmental representation. Poster presented at the 2020 Annual Meeting of the LSA.\nDanis, Nick. Cross-category agreement as reference to general dominance. AMP 2018, UC San Diego. Oct 5-7, 2018. Poster. [conf. link]\nDanis, Nick, Jeffrey Heinz and Adam Jardine. 2018. How constraints refer to nothing: The correct notion of substructure for phonology. Poster that was present at the 2018 LSA.\nDanis, Nick. 2018. A theory of cross-category agreement and new evidence for unified place features. Poster that never made it to the 2018 LSA due to inclement weather. See the AMP 2018 version.\nDanis, Nick. 2017. Phonetics of Yoruba vowel deletion: durational evidence for hidden structure. ACAL 48, Indiana University. March 30-April 2, 2017. Poster.\n\n\n\n\n\n\nDuggan, Jacob. 2023. Why WUTSL? A Grammar for Wh-Movement and Tier-based Strictly Local Syntax’s Computation Tool. Senior honor’s thesis, Washington University in St. Louis. (primary advisor)\nCalhoun, Adrianna. 2021. Invisible Issues: Exploring the Unspoken Rift Between the Black Community and the Field of Speech-Language Pathology. Senior honor’s thesis, Washington University in St. Louis. (reader)\nGoldberg, Jack. 2021. Phonological treatment of affricates in Yiddish and segmental analysis. Poster presented at CULC 15. (directed study)\nZhang, Yutong. 2021. A phonological analysis of the word-borrowing process in Volapük. Senior honor’s thesis, Washington University in St. Louis. (primary advisor)\nGoldberg, Jack. 2020. Phonological treatment of affricates in Yiddish. Poster presented at Midphon 25. (directed study)"
  },
  {
    "objectID": "publications.html#presentations",
    "href": "publications.html#presentations",
    "title": "Publications",
    "section": "",
    "text": "Danis, Nick. 2026. Representing phonology in the formal comparison of phonological representations. Keynote speaker, Workshop on The Role of Representation in Computational Phonology. OCP23 satellite workshop. University of Cambridge, January 13, 2026.\nDanis, Nick. 2024. Comparing representations: Towards a strong generative capacity for phonology. Invited speaker, RULing 2024, Rutgers University, May 3, 2024. [python supplement]\nDanis, Nick. 2023. Comparing representations: Towards a strong generative capacity for phonology. Invited colloquium, GSAS Circles Talk, Harvard University, February 17, 2023.\nDanis, Nick. 2022. Comparing phonological representations. Invited keynote, Graduate Linguistics Expo at Michigan State (GLEAMS) 2022. Michigan State University, October 28-29, 2022.\n\n\n\n\n\nDanis, Nick. 2022. Natural class-preserving transductions among phonological representations. Workshop on Model-Theoretic Representations in Phonology. Stony Brook University, September 22-24, 2022.\nDanis, Nick and Adam Jardine. 2019. Q-Theory Representations are logically equivalent to Autosegmental Representations. SCiL, co-meeting with the LSA 2019.\nDanis, Nick. 2016. Major place harmony and the (reduced) role of representation: Evidence from Ngbaka. AMP 2016. USC. October 21-23, 2016.\nDanis, Nick. 2016. Cross-category vowel-consonant interactions in Aghem and Vietnamese. Presented at the University of Chicago Phonology Group, May 13, 2016.\nDanis, Nick. 2015. Markedness and Complex Segments: Evidence from Simplification Processes. 8th World Congress of African Linguistics. Presented Talk. Kyoto University. August 21, 2015.\nDanis, Nick. 2015. A Typology of Complex Segments: Multiple Place Interactions on a Scale. Workshop on Formal Typologies. Rutgers University, May 30, 2015.\nDanis, Nick. 2015. Complex Segments Made Simple: Markedness and Doubly-Articulated Stops. 46th Annual Conference on African Linguistics. Presented Talk. University of Oregon. March 27, 2015.\nDanis, Nick, Jonathan Barnes, and Catherine O’Connor. 2011. Downstep and Contour Formation in Medumba: A Grassfields Bantu Language. 42th Annual Conference on African Linguistics. Presented Talk. University of Maryland.\n\n\n\n\n\nDanis, Nick. 2024. Logical transductions are not sufficient for notational equivalence. Poster presented at the Annual Meeting on Phonology (AMP) 2024. Rutgers University, November 1-3, 2024.\nDanis, Nick. 2024. Logical transductions are not sufficient for notational equivalence. Poster presented at the 29th Mid-Continental Phonetics and Phonology Conference (MidPhon 29). University of Illinois at Urbana-Champaign, October 4–5, 2024. (See AMP 2024 link for poster PDF.)\nDanis, Nick. 2020. Phonology needs geometry: Implicit axioms in segmental representation. Poster presented at the 2020 Annual Meeting of the LSA.\nDanis, Nick. Cross-category agreement as reference to general dominance. AMP 2018, UC San Diego. Oct 5-7, 2018. Poster. [conf. link]\nDanis, Nick, Jeffrey Heinz and Adam Jardine. 2018. How constraints refer to nothing: The correct notion of substructure for phonology. Poster that was present at the 2018 LSA.\nDanis, Nick. 2018. A theory of cross-category agreement and new evidence for unified place features. Poster that never made it to the 2018 LSA due to inclement weather. See the AMP 2018 version.\nDanis, Nick. 2017. Phonetics of Yoruba vowel deletion: durational evidence for hidden structure. ACAL 48, Indiana University. March 30-April 2, 2017. Poster."
  },
  {
    "objectID": "publications.html#student-work",
    "href": "publications.html#student-work",
    "title": "Publications",
    "section": "",
    "text": "Duggan, Jacob. 2023. Why WUTSL? A Grammar for Wh-Movement and Tier-based Strictly Local Syntax’s Computation Tool. Senior honor’s thesis, Washington University in St. Louis. (primary advisor)\nCalhoun, Adrianna. 2021. Invisible Issues: Exploring the Unspoken Rift Between the Black Community and the Field of Speech-Language Pathology. Senior honor’s thesis, Washington University in St. Louis. (reader)\nGoldberg, Jack. 2021. Phonological treatment of affricates in Yiddish and segmental analysis. Poster presented at CULC 15. (directed study)\nZhang, Yutong. 2021. A phonological analysis of the word-borrowing process in Volapük. Senior honor’s thesis, Washington University in St. Louis. (primary advisor)\nGoldberg, Jack. 2020. Phonological treatment of affricates in Yiddish. Poster presented at Midphon 25. (directed study)"
  },
  {
    "objectID": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html",
    "href": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html",
    "title": "Instantly making PDFs with Graphviz from Markdown files in VSCode",
    "section": "",
    "text": "Graphviz is a popular and powerful engine for creating diagrams and graphs without having to worry about the layout (usually…). VSCode has existing extensions that will show you the compiled graphviz diagram in your markdown file directly. This post explains how to turn that markdown file into a PDF instantly. This is handy for creating quick handouts that don’t require the time or finesse of something like TikZ/LaTeX. This particular method requires VSCode and a number of extensions."
  },
  {
    "objectID": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html#required-extensions-and-modules",
    "href": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html#required-extensions-and-modules",
    "title": "Instantly making PDFs with Graphviz from Markdown files in VSCode",
    "section": "Required extensions and modules",
    "text": "Required extensions and modules\n\nVSCode\nMarkdown All in One, among many other things, generates an HTML file from the Markdown source.\nGraphviz Markdown Preview compiles any graphviz code inside a graphviz labeled codeblock in a markdown file into a visual diagram.\nWith support for LaTeX-style math equations as well, this might be enough for some. To make sure the graphviz diagrams are shown the same for everyone who sees the file, though, it’s nice to have it as a pdf.\n\n\nPython\nThe core conversion to a PDF file is done via headless Chrome. This allows you to use Chrome’s print to PDF function without actually opening the application window. If Chrome is installed, this can be done with the following command (depending on your OS):\nchrome --headless --disable-gpu --print-to-pdf https://www.nickdanis.com/\nLocal html files work the same way; just include the path instead of the URL. However, to automate the process, you can make a python script that uses these same tools under the hood. I based mine around pyhtml2pdf. This package can do the following:\nfrom pyhtml2pdf import converter\nconverter.convert(f'file:///{input_path}', 'output.pdf')\nHere, input_path is the full path to the HTML file, and output.pdf is the resulting PDF file. This package should download the necessary Chrome web drivers necessary if your computer does not already have them installed."
  },
  {
    "objectID": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html#automating-the-process",
    "href": "posts/2021-06-16-instantly-making-pdfs-graphviz-markdown-files-vscode.html#automating-the-process",
    "title": "Instantly making PDFs with Graphviz from Markdown files in VSCode",
    "section": "Automating the process",
    "text": "Automating the process\nSo far, you can invoke the Print to HTML function from VSCode to convert a Graphviz-rich markdown file to an HTML file, and then use either a shell command or python script to convert that to a PDF file. Note that the HTML files outputted by this extension are quite large (in my case, about 2mb for a simple markdown file), as there is lots of embedded code. First, we will build a python script that takes a filename as an argument, and then we will combine these tools into a VSCode Task.\n\nThe python script\nThe following script accepts and requires a single argument in the commandline. This should be the name of the file to be converted. The converter needs an html file.\nimport sys, os, re\nfrom pyhtml2pdf import converter\n\n# save working directory\ncwd = os.getcwd()\n\n# get passed argument\ninput_raw = sys.argv[1]\n\n# substitute file extension (more on this later)\ninput_name = re.sub(r'\\.md','.html',input_raw)\ninput_path = os.path.abspath(input_name)\n\n# create output name dot pdf\noutput_name = re.sub('\\.md','.pdf',input_raw)\n\n# the actual conversion\nconverter.convert(f'file:///{input_path}', output_name)\n\n# delete the html file\nos.remove(input_name)\nSave this somewhere. Maybe in the current project directory for now.\n\n\nThe build task\nThe converter object needs an HTML file. However, in VSCode, work is done on a Markdown file. Invoking the Print current document to HTML command will generate a file, but then we still have to pass this file to the script. To do this all in one step, we will create two tasks: one for MD to HTML, and one for HTML to PDF. Then, we will create a compound task, that runs these in order. This compound task will be the one that does the conversion in a single step. In VSCode, open the command palette and find Tasks: Open User Tasks. Mine looks like this.\n{\n    \"version\":\"2.0.0\",\n    \"tasks\":[\n        {\n            \"label\": \"MD-to-HTML\",\n            \"command\": \"${command:markdown.extension.printToHtml}\",\n            \"problemMatcher\": []\n        },\n        {\n            \"label\": \"HTML-to-PDF\",\n            \"type\": \"shell\",\n            \"command\": \"python {PATH-TO-SCRIPT}.py ${file}\"\n        },\n        {\n            \"label\": \"BuildPDF\",\n            \"dependsOn\": [\n                \"MD-to-HTML\",\n                \"HTML-to-PDF\"\n            ],\n            \"problemMatcher\": []\n        }\n    ]\n}\nYou will need to replace {PATH-TO-SCRIPT} with whatever the path is to your script. The first task, MD-to-HTML, simply calls the command to conver the Markdown file to HTML. On calling this task, an HTML file with the same basename as the markdown file will appear in the current directory. The second task, HTML-to-PDF, runs the python script created earlier. Notice that it’s called with the ${file} variable after it; this means VSCode will pass the current file’s name as an argument, which the script then parses. However, this argument has an .md extension, because that’s all VSCode sees at the time of the compound task call. The few lines of python code are there to replace .md in the filename string to .html. We can be sure that this HTML file will always be present because of the BuildPDF compound task. This task as the property dependsOn, which takes a list of existing tasks (called by their \"label\".) Because MD-to-HTML is called first, the necessary HTML file will always be there for HTML-to-PDF to convert.\nAt this point, it’s done. BuildPDF can be invoked from the command palatte by name, and a PDF of the active markdown file will appear in the working directory. The HTML file is deleted in the process to avoid bloat. From here, you can also set a keyboard shortcut for the compound task, so it is indeed instant."
  },
  {
    "objectID": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html",
    "href": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html",
    "title": "How to make a vowel chart using matplotlib and python",
    "section": "",
    "text": "This post explains several methods for plotting a phonetic vowel space from F1 and F2 values. The data here is generated randomly, but any Excel or CSV file of your own can be imported in its place.\nThis post is also available as a jupyter notebook here."
  },
  {
    "objectID": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#getting-some-data",
    "href": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#getting-some-data",
    "title": "How to make a vowel chart using matplotlib and python",
    "section": "Getting some data",
    "text": "Getting some data\nFor our vowel plot, we’ll start with some example formant values from the Language Files textbook. If you already have data ready to work with, skip to the Making the plot section below. They give the following F1 and F2 values for a typical American English speaker. These are defined in a dictionary, which is used to create the initial pandas dataframe lf_df. Import the necessary packages, and define the initial dataframe.\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nimport numpy as np\n# \"Typical\" formant values for AmE, from Language Files 12 p. 79\nlf_vowels = {'vowel' : ['i','ɪ','ɛ','æ','u','ʊ','ɔ','ɑ'],\n            'F1' : [280, 400, 550, 690, 310, 450, 590, 710],\n            'F2' : [2250, 1920, 1770, 1660, 870, 1030, 880, 1100]}\n\ndf = pd.DataFrame(lf_vowels)\nTo get the full effect of our plot, the following block generates dummy values for 20 additional tokens for each type of vowel. F1 and F2 are defined as the values straight from Language Files. Random values are generated with the following two lines:\nrand_F1s = np.random.randint(.8*F1, 1.2*F1, 20)\nrand_F2s = np.random.randint(.8*F2, 1.2*F2, 20)\nThe first argument, .8*F1, sets a lower bound of 80% of the given formant value, and the second arguments sets an upper bound of 120% of the given formant value. 20 integers between these bounds are randomly generated, and added to the initial dataframe.\n# Generate dummy formant values based on LF values:\nfor v in df.vowel.unique():\n    F1 = df.F1.loc[df.vowel == v].values[0]\n    F2 = df.F2.loc[df.vowel == v].values[0]\n    rand_F1s = np.random.randint(.8*F1, 1.2*F1, 20)\n    rand_F2s = np.random.randint(.8*F2, 1.2*F2, 20)\n    new_vs = pd.DataFrame({'vowel' : list(v*20), 'F1' : list(rand_F1s), 'F2' : list(rand_F2s)})\n    df = pd.concat([df,new_vs], ignore_index=True)\n    \n#print(lf_df.sample(10).to_markdown())\nThe resulting dataframe now has additional values for each vowel, like the sample below shows.\n\n\n\n\nvowel\nF1\nF2\n\n\n\n\n462\nɔ\n652\n783\n\n\n503\ni\n302\n1895\n\n\n2\nɛ\n550\n1770\n\n\n414\nu\n312\n707\n\n\n584\nu\n329\n704\n\n\n319\nɑ\n600\n1099\n\n\n449\nɔ\n533\n831\n\n\n418\nu\n369\n816\n\n\n629\nɑ\n568\n1000\n\n\n535\nɛ\n620\n1530\n\n\n\nIf you are importing your own data, make sure you adjust for the column headings as defined here. (The leftmost column is the index and can be ignored.)"
  },
  {
    "objectID": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#making-the-plot",
    "href": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#making-the-plot",
    "title": "How to make a vowel chart using matplotlib and python",
    "section": "Making the plot",
    "text": "Making the plot\nThere are multiple ways to plot vowels. The strategy in the code below is to plot every formant value with a blank marker (or symbol), and then to loop through the vowels themselves and annotating the points with the vowel symbols themselves.\nPlotting the values is done below:\nfig, ax = plt.subplots(figsize=(10,8))\n\nx_name = 'F2'\ny_name = 'F1'\n\nx = df[x_name]\ny = df[y_name]\n\nax.scatter(x, y)\nplt.show()\n\n\n\npng\n\n\nThe variables x_name and y_name simply store a string that will be used both to get columns in the dataframe and to use as eventual axis labels. The x and y variables are the numerical data themselves, defined as Series objects from our dataframe using the x_name and y_name variables. The plot is pretty terrible so far, because there’s nothing to tell the vowels apart. This will be done with annotations. To see how it can be done by plotting each vowel separately, see the alternate strategy at the end.\nfig, ax = plt.subplots(figsize=(10,8))\n\nx_name = 'F2'\ny_name = 'F1'\n\nx = df[x_name]\ny = df[y_name]\n\nax.scatter(x, y,marker=\"\")\n\ncmap = cm.get_cmap('Dark2')\nfor v, color in zip(df.vowel.unique(),cmap.colors):\n    X = df[x_name].loc[df.vowel == v]\n    Y = df[y_name].loc[df.vowel == v]\n    for x, y in zip(X,Y):\n        ax.annotate(v,(x,y), xytext = (0,0), textcoords='offset points',fontsize=14,color=color)\n\nplt.show()\n\n\n\npng\n\n\nThe code above sets the marker to nothing \"\", and adds the following for loop:\ncmap = cm.get_cmap('Dark2')\nfor v, color in zip(df.vowel.unique(),cmap.colors):\n    X = df[x_name].loc[df.vowel == v]\n    Y = df[y_name].loc[df.vowel == v]\n    for x, y in zip(X,Y):\n        ax.annotate(v,(x,y), xytext = (0,0), textcoords='offset points',fontsize=14,color=color)\ndf.vowel.unique() isolates all unique entries in the 'vowels' column of the dataframe, and the cmap.colors object contains a list of colors as defined by cmap = cm.get_cmap('Dark2'). (Note that you should also have from matplotlib import cm in your code.) Colormaps are predefined gradients and lists of colors that are built in to matplotlib. If you print cmap.colors you should see simply a list of color values. The zip() function in the for loop pairs each vowel type with a specific color.\nThe capital X and Y variables are defined as all format values (F2 and F1, respectively) for those individual vowels. Because each vowel has multiple vowels, there is another nested for loop that zips X and Y once again. Each (x, y) pair here are the values for that particular vowel.\nThe ax.annotate(v,(x,y),fontsize=14,color=color) command says: - put the text label v, which here is the vowel symbol, as defined by the outer for loop - at coordinates (x,y), defined by the inner for loop - at size 14 - as color color, where color is the current color in the cmap list defined.\nAs the outer for loop iterates to the next unique vowel symbol, the color will change as well. When we see this on the plot, each grouping of the same vowel is colored distinctly from the others.\nOur plot is pretty good so far, except…it’s upside down! And flipped! High, front vowels are in the low, back section. We need to invert each axis, and add some labels and a title for posterity. The following code accomplishes this. It also moves the tick locations to the top and the right, which is optional but not uncommon with vowel plots. Note that the axis labels are defined with the x_name and y_name variables as defined previously. This is optional, but I find it convenient.\ncmap = cm.get_cmap('Dark2')\n\nfig, ax = plt.subplots(figsize=(10,8))\n\nx_name = 'F2'\ny_name = 'F1'\n\nx = df[x_name]\ny = df[y_name]\n\nax.scatter(x, y,marker=\"\")\n\nfor v, color in zip(df.vowel.unique(),cmap.colors):\n    X = df[x_name].loc[df.vowel == v]\n    Y = df[y_name].loc[df.vowel == v]\n    for x, y in zip(X,Y):\n        ax.annotate(v,(x,y),fontsize=14,color=color)\n\nax.invert_xaxis()\nax.invert_yaxis()\nax.set_xlabel(x_name,fontsize=16)\nax.set_ylabel(y_name,fontsize=16)\nax.yaxis.tick_right()\nax.xaxis.tick_top()\nax.yaxis.set_label_position(\"right\")\nax.xaxis.set_label_position(\"top\")\nax.set_title('Vowels',fontsize=18)\n#ax.grid()\n#plt.savefig('my_vowel_plot.png')\nplt.show()\n\n\n\npng\n\n\nAnd that’s it! It can be customized further, or exported as-is. Uncommenting the plt.savefig() command will save the plot to a file with the given name, for use in papers and presentations."
  },
  {
    "objectID": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#alternate-plotting-method-i-am-legend",
    "href": "posts/2021-06-03-how-to-make-a-vowel-chart-using-matplotlib.html#alternate-plotting-method-i-am-legend",
    "title": "How to make a vowel chart using matplotlib and python",
    "section": "Alternate plotting method: I am Legend",
    "text": "Alternate plotting method: I am Legend\nThe method below includes only a single for loop, and calls the ax.scatter() command for every unique vowel, adding a label each time. The label is used when printing the legend with the plt.legend() command. This method has the advantage that matplotlib will choose a new color for you for each vowel (which you can always of course customize), but depending on the colors, the vowel quality of certain points might not be obvious to identify.\nfig, ax = plt.subplots(figsize=(10,8))\n\nfor v in df.vowel.unique():\n    x = df.F2.loc[df.vowel == v]\n    y = df.F1.loc[df.vowel == v]\n    ax.scatter(x, y, label=v)\n\nax.set_xlabel('F2',fontsize=16)\nax.set_ylabel('F1',fontsize=16)\nax.set_title('Vowels',fontsize=18)\nax.yaxis.tick_right()\nax.yaxis.set_label_position(\"right\")\nax.xaxis.tick_top()\nax.xaxis.set_label_position(\"top\")\nax.invert_xaxis()\nax.invert_yaxis()\nax.grid()\nplt.legend()\nplt.show()\n\n\n\npng"
  },
  {
    "objectID": "posts/2021-04-27-how-to-write-phonological-rule.html",
    "href": "posts/2021-04-27-how-to-write-phonological-rule.html",
    "title": "How to write a phonological rule in Microsoft Word",
    "section": "",
    "text": "The equation editor in Word allows matrices and brackets of various sizes, which is 90% of what we need to make a rule.\nLet us recreate the following rule from page 352 of Sound Pattern of English:\n\n\n\nScreenshot of rule from Sound Pattern of English page 352.\n\n\nThis rule uses ɑ notation to quantify over feature values, and each part of the rule is an explicit feature matrix.\nPhonological rules in Word are created using the Equation editor, so to start, go to Insert on the ribbon, and click Equation, under the Symbols section. (The following directions are for the Windows version of Word, though the process is similar on other platforms.)\nFor the first feature matrix, insert a pair of square Brackets.\n\n\n\nInsert brackets for each feature matrix.\n\n\nThe brackets will automatically resize depending on whatever is inside. Make sure the outlined box is gray (use the arrows to move the cursor left and right until this is the case), then select Matrix, and select the 1x2 matrix. The size of the matrix will correspond to the number of features in the feature matrix. In the top element of the feature matrix, type “-son”. You will notice that it appears in a slightly italic looking style, with awkward spacing. This is because by default Word expects parts of an equation, not words. Select what you just typed, and click “Text” at the top. This tells Word that this part of the equation is plain text. (I like to leave the hyphen unchanged so it registers a true minus sign.)\n\n\n\nChange feature names to plain text.\n\n\nComplete the feature matrix in the same way. When you need to insert the arrow in the rule, one is available in the “Symbols” window in the ribbon. When you get to the part of the rule separated by a slash “/”, you might see the equation editor interpret this as the desire to insert a fraction:\n\nIf this happens, undo, and click “Text” before you type the slash. Now it will appear as expected, and you can continue adding bracketed feature matrices for the rest of the rule. Again, Word may interpret the underscore as a subscripted element, so be sure to hit Text before typing the underscore as well. I used a sequence of three underscores in my final version of the rule, shown below:\n\n\n\nImage of final rule, with the slash and underscore as plain text.\n\n\nThe rule now exists as an Equation. If you want it to look more like the original SPE rule, you can change the justification of the Matrix elements to be left-aligned instead of centered by right-clicking an element in a matrix and choosing Left from Column Alignment:\n\n\n\nChange column alignment to better match visually the original rule.\n\n\nMoving forward, you might want to create a rule template that you will use often. To do so, select “Save as New Equation” after clicking the arrow in the bottom-right corner of the equation border.\n\n\n\nSave rule template to the Equations gallery.\n\n\nNow, you can insert the rule with a single click from the Equations gallery accessible from the Equation ribbon.\n\n\n\nSelect rule from the Equations gallery for easy insertion next time.\n\n\nAs Equations, the rules can be shown centered on their own lines, or inline with text. Learning the general properties of the Equation editor in Word will help you better incorporate the rules into your work."
  },
  {
    "objectID": "posts/2020-03-07-typing-ipa-symbols.html",
    "href": "posts/2020-03-07-typing-ipa-symbols.html",
    "title": "Typing IPA symbols on your computer",
    "section": "",
    "text": "For doing any serious phonetic or phonological work, you should have a fully IPA compliant Unicode font installed. While many phonetic symbols are accessible without these fonts, not all handle the full range of symbols and diacritics properly. The SIL provides several such fonts for free:\n\nDoulos SIL\nCharis SIL\n\nUsing one of these fonts will ensure that you have the full range of all IPA symbols and diacritics in a consistent font face.\nIn order to type with the font, it is best to install a custom keyboard mapping. In essence, you will be installing the IPA as a “language” for your operating system, and switching to this mode will change the behavior of your keyboard to make typing IPA direct and easy.\nSIL also provides such IPA keyboards for both Windows and macOS, and Linux through the open source Keyman app. When downloading the application, you have the option of selecting the IPA keyboard bundle, so both are installed at the same time. Follow the instructions on the download site.\nOn Windows, the keyboard shortcut Windows + Space will change the language of Windows. This can also be selected by clicking the current language in the taskbar:\n\n\n\nscreenshot showing IPA language location in taskbar\n\n\nOnce installed and enabled, you now have full access to all IPA characters using just your keyboard. See the provided documentation for a full guide on how to type the symbols themselves.\nThis documentation show the IPA chart in its normal layout annotated with the keystrokes for each. I recommend saving these pages as reference and having them handy whenever you are doing any word.\nTo type the velar nasal ŋ, for instance, type ‘n’ followed by the greater-than symbol &gt;.\n\nNow you are cooking with gas."
  },
  {
    "objectID": "cv.html",
    "href": "cv.html",
    "title": "CV",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "assets/code/natural_class_extensions.html",
    "href": "assets/code/natural_class_extensions.html",
    "title": "Natural-class preserving structures",
    "section": "",
    "text": "Nick Danis / nsdanis@wustl.edu / www.nickdanis.com\nSupplemental material for Natural class-preserving transductions among phonological representations, presented at the Workshop on Model-Theoretic Representations in Phonology at Stony Brook University, September 22-24, 2022.\nfrom itertools import chain, combinations\n\n# from https://stackoverflow.com/questions/1482308/how-to-get-all-subsets-of-a-set-powerset\ndef powerset(iterable):\n    \"powerset([1,2,3]) --&gt; () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\ndef get_shared_structure(segs, theory):\n    '''\n    find the shared vertices and edges between the structures in a theory\n    '''\n    structures = []\n    for seg in segs:\n        structures.append(theory[seg])\n    return set.intersection(*structures)\n\ndef add_verteces(theory):\n    '''\n    programmatically add the vertex set to each representation\n    based on the edges present\n    '''\n    for seg in theory.keys():\n        verteces = set()\n        for edge in theory[seg]:\n            for v in edge:\n                verteces.add(v)\n        theory[seg].update(verteces)\n    #return theory\n\ndef generate_extensions(theory):\n    '''from the segments in the theory, generate the powerset\n    (with singletons removed)'''\n    natural_classes = powerset(theory.keys())\n    return [nat for nat in natural_classes if len(nat) &gt; 1]\n\ndef generate_shared_structure(theory):\n    add_verteces(theory)\n    shared = dict()\n    for nat in generate_extensions(theory):\n        nat_struct = get_shared_structure(nat,theory)\n        if len(nat_struct) &gt; 0:\n            shared[nat] = nat_struct\n    return shared\n        \ndef generate_nce(theory):\n    nce = dict()\n    shared = generate_shared_structure(theory)\n    for nat in shared:\n        # get the segments not included in this class\n        rest = set(theory.keys()) - set(nat)\n        # initialize a list of potentially missing segments\n        missing = []\n        #print(nat, rest)\n        # iterate through the rest\n        for seg in rest:\n            #print(f\"current common structure is {yip_nce[nat]}\")\n            if shared[nat].issubset(theory[seg]):\n                missing.append(seg)\n        if len(missing) == 0:\n            nce[tuple(sorted(list(nat)))] = shared[nat]\n    return nce\n\n\ndef compare_theories(theory1, theory2, verbose=False):\n    nce1 = generate_nce(theory1)\n    nce2 = generate_nce(theory2)\n    print(f\"Natural classes unique to theory 1:\")\n    unique1 = nce1.keys() - nce2.keys()\n    for nce in unique1:\n        if verbose:\n            print(f\"{nce}\\n\\t{nce1[nce]}\")\n        else:\n            print(f\"{nce}\")\n    print(f\"Natural classes unique to theory 2:\")\n    unique2 = nce2.keys() - nce1.keys()\n    for nce in unique2:\n        if verbose:\n            print(f\"{nce}\\n\\t{nce2[nce]}\")\n        else:\n            print(f\"{nce}\")\n    print(\"Natural classes in common:\")\n    common = nce2.keys() & nce1.keys()\n    for nce in common:\n        if verbose:\n            print(f\"{nce}\\nT1:\\t{nce1[nce]}\\nT2:\\t{nce2[nce]}\")\n        else:\n            print(f\"{nce}\")"
  },
  {
    "objectID": "assets/code/natural_class_extensions.html#oakden-2021",
    "href": "assets/code/natural_class_extensions.html#oakden-2021",
    "title": "Natural-class preserving structures",
    "section": "Oakden 2021",
    "text": "Oakden 2021\n\nyip = {\n    'L' : {('s','-u'), ('-u','l')},\n    'H' : {('s','+u'), ('+u','h')},\n    'M1' : {('s','-u'), ('-u','h')},\n    'M2' : {('s','+u'), ('+u','l')},\n    'HM' : {('s','+u'), ('+u','h'), ('+u','l')},\n    'MH' : {('s','+u'), ('+u','l'), ('+u','h')},\n    'ML' : {('s','-u'), ('-u','l'), ('-u','h')},\n    'LM' : {('s','-u'), ('-u','l'), ('-u','h')}\n}\n\nbao = {\n    'L' : {('s','T'), ('T','-u'), ('T','c'), ('c','l')},\n    'H' : {('s','T'), ('T','+u'), ('T','c'), ('c','h')},\n    'M1' : {('s','T'), ('T','-u'), ('T','c'), ('c','h')},\n    'M2' : {('s','T'), ('T','+u'), ('T','c'), ('c','l')},\n    'HM' : {('s','T'), ('T','+u'), ('T','c'), ('c','h'), ('c','l')},\n    'MH' : {('s','T'), ('T','+u'), ('T','c'), ('c','h'), ('c','l')},\n    'ML' : {('s','T'), ('T','-u'), ('T','c'), ('c','h'), ('c','l')},\n    'LM' : {('s','T'), ('T','-u'), ('T','c'), ('c','h'), ('c','l')},\n}\n\ncompare_theories(yip, bao)\n\nNatural classes unique to theory 1:\nNatural classes unique to theory 2:\nNatural classes in common:\n('HM', 'MH')\n('H', 'HM', 'L', 'LM', 'M1', 'M2', 'MH', 'ML')\n('LM', 'M1', 'ML')\n('HM', 'LM', 'MH', 'ML')\n('H', 'HM', 'M2', 'MH')\n('H', 'HM', 'MH')\n('HM', 'M2', 'MH')\n('L', 'LM', 'M1', 'ML')\n('H', 'HM', 'LM', 'M1', 'MH', 'ML')\n('HM', 'L', 'LM', 'M2', 'MH', 'ML')\n('L', 'LM', 'ML')\n('LM', 'ML')"
  },
  {
    "objectID": "assets/code/natural_class_extensions.html#segment-version",
    "href": "assets/code/natural_class_extensions.html#segment-version",
    "title": "Natural-class preserving structures",
    "section": "4-segment version",
    "text": "4-segment version\n\nunified = {\n    'p' : {('rt','Cpl'), ('Cpl','lab')},\n    't' : {('rt','Cpl'), ('Cpl','cor')},\n    'u' : {('rt','Vpl'), ('Vpl','lab')},\n    'pw' : {('rt','Cpl'), ('Cpl','lab'), ('rt','Vpl'), ('Vpl','lab')},\n    \n}\n\nv_features = {\n    'p' : {('rt','Pl'), ('Pl','lab'), ('rt','-rnd')},\n    't' : {('rt','Pl'), ('Pl','cor'), ('rt','-rnd')},\n    'pw' : {('rt','Pl'), ('Pl','lab'), ('rt','+rnd')},\n    'u' : {('rt','+rnd')},\n}\n\ncompare_theories(unified, v_features)\n\nNatural classes unique to theory 1:\n('p', 'pw', 'u')\nNatural classes unique to theory 2:\n('p', 't')\nNatural classes in common:\n('p', 'pw')\n('p', 'pw', 't', 'u')\n('p', 'pw', 't')\n('pw', 'u')"
  },
  {
    "objectID": "assets/code/natural_class_extensions.html#full-combinations",
    "href": "assets/code/natural_class_extensions.html#full-combinations",
    "title": "Natural-class preserving structures",
    "section": "Full combinations",
    "text": "Full combinations\n\nunified_d = {\n    'p' : {('rt','Cpl'), ('Cpl','lab')},\n    't' : {('rt','Cpl'), ('Cpl','cor')},\n    'u' : {('rt','Vpl'), ('Vpl','lab')},\n    'i' : {('rt','Vpl'), ('Vpl','cor')},\n    'pw' : {('rt','Cpl'), ('Cpl','lab'), ('rt','Vpl'), ('Vpl','lab')},\n    'tw' : {('rt','Cpl'), ('Cpl','cor'), ('rt','Vpl'), ('Vpl','lab')},\n    'pj' : {('rt','Cpl'), ('Cpl','lab'), ('rt','Vpl'), ('Vpl','cor')},\n    'tj' : {('rt','Cpl'), ('Cpl','cor'), ('rt','Vpl'), ('Vpl','cor')},\n    \n}\n\nv_features_d = {\n    'p' : {('rt','Pl'), ('Pl','lab'), ('rt','-rnd'), ('rt','-front')},\n    't' : {('rt','Pl'), ('Pl','cor'), ('rt','-rnd'), ('rt','-front')},\n    'u' : {('rt','+rnd'), ('rt','-front')},\n    'i' : {('rt','-rnd'), ('rt','+front')},\n    'pw' : {('rt','Pl'), ('Pl','lab'), ('rt','+rnd'), ('rt','-front')},\n    'tw' : {('rt','Pl'), ('Pl','cor'), ('rt','+rnd'), ('rt','-front')},\n    'pj' : {('rt','Pl'), ('Pl','lab'), ('rt','-rnd'), ('rt','+front')},\n    'tj' : {('rt','Pl'), ('Pl','cor'), ('rt','-rnd'), ('rt','+front')},\n\n}\n\ncompare_theories(unified, v_features)\n\nNatural classes unique to theory 1:\n('p', 'pw', 'u')\nNatural classes unique to theory 2:\n('p', 't')\nNatural classes in common:\n('p', 'pw')\n('p', 'pw', 't', 'u')\n('p', 'pw', 't')\n('pw', 'u')"
  },
  {
    "objectID": "assets/code/natural_class_extensions.html#three-places-with-double-articulations",
    "href": "assets/code/natural_class_extensions.html#three-places-with-double-articulations",
    "title": "Natural-class preserving structures",
    "section": "Three places, with double articulations",
    "text": "Three places, with double articulations\n\nunified_e = {\n    'p' : {('rt','Cpl'), ('Cpl','lab')},\n    't' : {('rt','Cpl'), ('Cpl','cor')},\n    'k' : {('rt','Cpl'), ('Cpl','dors')},\n    'u' : {('rt','Vpl'), ('Vpl','lab')},\n    'i' : {('rt','Vpl'), ('Vpl','cor')},\n    'pw' : {('rt','Cpl'), ('Cpl','lab'), ('rt','Vpl'), ('Vpl','lab')},\n    'tw' : {('rt','Cpl'), ('Cpl','cor'), ('rt','Vpl'), ('Vpl','lab')},\n    'kw' : {('rt','Cpl'), ('Cpl','dors'), ('rt','Vpl'), ('Vpl','lab')},\n    'pj' : {('rt','Cpl'), ('Cpl','lab'), ('rt','Vpl'), ('Vpl','cor')},\n    'tj' : {('rt','Cpl'), ('Cpl','cor'), ('rt','Vpl'), ('Vpl','cor')},\n    'kj' : {('rt','Cpl'), ('Cpl','dors'), ('rt','Vpl'), ('Vpl','cor')},\n    'kp' : {('rt','Cpl'), ('Cpl','dors'), ('Vpl','lab')},\n    'tp' : {('rt','Cpl'), ('Cpl','cor'), ('Vpl','lab')},\n    \n}\n\nv_features_e = {\n    'p' : {('rt','Pl'), ('Pl','lab'), ('rt','-rnd'), ('rt','-front')},\n    't' : {('rt','Pl'), ('Pl','cor'), ('rt','-rnd'), ('rt','-front')},\n    'k' : {('rt','Pl'), ('Pl','dors'), ('rt','-rnd'), ('rt','-front')},\n    'u' : {('rt','+rnd'), ('rt','-front')},\n    'i' : {('rt','-rnd'), ('rt','+front')},\n    'pw' : {('rt','Pl'), ('Pl','lab'), ('rt','+rnd'), ('rt','-front')},\n    'tw' : {('rt','Pl'), ('Pl','cor'), ('rt','+rnd'), ('rt','-front')},\n    'tw' : {('rt','Pl'), ('Pl','dors'), ('rt','+rnd'), ('rt','-front')},\n    'pj' : {('rt','Pl'), ('Pl','lab'), ('rt','-rnd'), ('rt','+front')},\n    'tj' : {('rt','Pl'), ('Pl','cor'), ('rt','-rnd'), ('rt','+front')},\n    'kj' : {('rt','Pl'), ('Pl','dors'), ('rt','-rnd'), ('rt','+front')},\n    'kp' : {('rt','Pl'), ('Pl','dors'), ('Pl','lab'), ('rt','-rnd'), ('rt','-front')},\n    'tp' : {('rt','Pl'), ('Pl','dors'), ('Pl','cor'), ('rt','-rnd'), ('rt','-front')},\n\n}\n\ncompare_theories(unified_e, v_features_e)\n\nNatural classes unique to theory 1:\n('kj', 'pj', 'tj', 'tw')\n('i', 'k', 'kj', 'kp', 'kw', 'p', 'pj', 'pw', 't', 'tj', 'tp', 'tw', 'u')\n('kw', 'pj', 'pw', 'tw', 'u')\n('kp', 'kw')\n('p', 'pj', 'pw')\n('kj', 'kw', 'pj', 'pw', 'tj', 'tw')\n('i', 'kj', 'pj', 't', 'tj', 'tp', 'tw')\n('pj', 'tw')\n('i', 'kj', 'kp', 'kw', 'pj', 'pw', 'tj', 'tp', 'tw', 'u')\n('pj', 'pw')\n('tj', 'tw')\n('pj', 'tp', 'tw')\n('i', 'kj', 'kw', 'pj', 'pw', 'tj', 'tw', 'u')\n('k', 'kj', 'kp', 'kw')\n('kp', 'kw', 'pw', 'tp', 'tw')\n('kj', 'kw')\n('kp', 'kw', 'pj', 'pw', 'tp', 'tw')\n('kw', 'pw', 'tw')\n('tj', 'tp', 'tw')\n('kw', 'pj', 'pw', 'tw')\n('kj', 'pj', 't', 'tj', 'tp', 'tw')\n('kj', 'pj', 'tj', 'tp', 'tw')\n('tp', 'tw')\n('kj', 'kp', 'kw', 'pj', 'pw', 'tj', 'tp', 'tw')\n('kj', 'kp', 'kw')\n('kp', 'kw', 'pw', 'tp', 'tw', 'u')\n('k', 'kj', 'kp', 'kw', 'p', 'pj', 'pw', 't', 'tj', 'tp', 'tw')\n('kp', 'kw', 'pj', 'pw', 'tp', 'tw', 'u')\n('kw', 'pw', 'tw', 'u')\n('kp', 'kw', 'p', 'pj', 'pw', 'tp', 'tw', 'u')\n('kp', 'kw', 'p', 'pj', 'pw', 'tp', 'tw')\n('i', 'kj', 'pj', 'tj', 'tp', 'tw')\n('i', 'kj', 'pj', 'tj', 'tw')\n('t', 'tj', 'tp', 'tw')\nNatural classes unique to theory 2:\n('i', 'k', 'kj', 'kp', 'p', 'pj', 't', 'tj', 'tp')\n('k', 'kp', 'p', 't', 'tp')\n('k', 'kj', 'kp', 'tp', 'tw')\n('k', 'kj', 'kp', 'p', 'pj', 't', 'tj', 'tp')\n('kp', 'p', 'pw')\n('k', 'kp', 'p', 'pw', 't', 'tp', 'tw')\n('i', 'k', 'kj', 'kp', 'p', 'pj', 'pw', 't', 'tj', 'tp', 'tw', 'u')\n('kp', 'p')\n('k', 'kj', 'kp', 'p', 'pj', 'pw', 't', 'tj', 'tp', 'tw')\n('kp', 'p', 'pj')\n('kp', 'p', 'pj', 'pw')\n('k', 'kp', 'tp', 'tw')\n('t', 'tp')\n('k', 'kj', 'kp', 'tp')\n('k', 'kp', 'tp')\n('pw', 'tw')\n('pw', 'tw', 'u')\n('t', 'tj', 'tp')\n('k', 'kp', 'p', 'pw', 't', 'tp', 'tw', 'u')\nNatural classes in common:\n('i', 'kj', 'pj', 'tj')\n('kj', 'pj', 'tj')"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Nick Danis",
    "section": "",
    "text": "I am a Senior Lecturer in linguistics at Washington University in St. Louis. See my teaching page for my current office hours and course info. My office on campus is January 206.\nMy focus is in theoretical and computational phonology. Empirical domains include local and long-distance assimilation processes, especially those involving complex segments, and segmental processes in general. Theoretically I am interested in the representation of segments, and how such representations differ in both a logical sense (in terms of computational power) and in the specific linguistic properties encoded. Read more about my research."
  },
  {
    "objectID": "posts/2020-12-27-how-send-canvas-announcement-email-app.html",
    "href": "posts/2020-12-27-how-send-canvas-announcement-email-app.html",
    "title": "How to send a Canvas announcement from your email app",
    "section": "",
    "text": "To send an announcement on Canvas, you normally use the Announcements tool specific to each course. However, you can also send announcements from your native email app using the external feeds feature on Canvas. To send an announcement via email, set up a dummy blog that supports RSS feeds and posting over email, then link that RSS feed with your Canvas site. The instructions below are for Blogger, but any platform that meets these requirements will work. When finished, you will be able to send announcements to one or all of your Canvas courses, from any email. […]\n\nFull post →"
  },
  {
    "objectID": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html",
    "href": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html",
    "title": "Exhaustive list of all ISO-morphic languages (languages whose name equals its ISO 639-3 code)",
    "section": "",
    "text": "Every unique language is assigned a three-letter code based on ISO 639-3 specifications. Information on these codes, and the data files used here, can be accessed here. (As you may now need a subscription to Ethnologue, also check out SIL and Glottolog.)\nAlso present in the world are languages whose names are three letters long (when in romanization). For this part, the language name is that in the primary ‘Name’ field of the Ethnologue data. Of the 7,000+ languages in Ethnologue, 235 have three-letter names, and of these, 58 of these are ISO-morphic: where the Name matches the ISO code.\nThe languages themselves are listed below, for your undoubtedly essential reference."
  },
  {
    "objectID": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html#iso-morphic-languages",
    "href": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html#iso-morphic-languages",
    "title": "Exhaustive list of all ISO-morphic languages (languages whose name equals its ISO 639-3 code)",
    "section": "ISO-morphic languages",
    "text": "ISO-morphic languages\n\nAdi\nAja\nAmo\nAyu\nCua\nDek\nDem\nDia\nDoe\nEfe\nEga\nEki\nElu\nEnu\nFam\nFoi\nFon\nFum\nFwe\nHiw\nHre\nHya\nIbu\nIdi\nIsu\nJeh\nKei\nKet\nKis\nKol\nLao\nLiv\nMam\nMbo\nNii\nNoy\nOku\nOmi\nOna\nOti\nRao\nTal\nTiv\nUbi\nUda\nUdi\nUtu\nVai\nVao\nWab\nWan\nWeh\nWom\nYao\nYis\nYoy\nYug\nZia"
  },
  {
    "objectID": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html#weakly-iso-morphic-languages",
    "href": "posts/2021-05-03-exhaustive-list-of-all-iso-morphic.html#weakly-iso-morphic-languages",
    "title": "Exhaustive list of all ISO-morphic languages (languages whose name equals its ISO 639-3 code)",
    "section": "Weakly ISO-morphic languages",
    "text": "Weakly ISO-morphic languages\nHowever, this compares the ISO code with the primary language name. Many languages have alternate names, and named dialects. All this information is available in the LanguageIndex.tab file. Each row is essentially an LangID, Name pair where the name is tagged as either primary, alternate, dialect, or alternate dialect. We can go further (why though?) by collecting all languages that contain any kind of alternate name or dialect that is ISO-morphic. These additional weakly ISO-morphic languages are shown below: at least one of the alternate names for or dialects of these languages is ISO-morphic\n\nDangme\nEloyi\nAmis\nPele-Ata\nTibetan, Central\nKaren, Bwe\nIbaas\nDay\nDass\nDyan\nEgyptian Sign Language\nEzaa\nGuatemalan Sign Language\nMbato\nHoro\nHawaii Sign Language\nIaai\nIgbo\nEde Ica\nInku\nYei\nDza\nJapanese Sign Language\nDholuo\nLuwo\nMru\nSamba Leko\nYuanga\nNgwe\nPe\nKrumen, Pye\nTarifit\nMeskwaki\nSeke\nYami\nUdihe\nFungwa\nUya\nUte-Southern Paiute\nFlemish Sign Language\n|Xam\nChinese, Yue\n\nYou’re welcome? Anyway, here’s the code."
  },
  {
    "objectID": "posts/2021-06-05-predicting-difficulty-new-york-times-crossword-puzzles.html",
    "href": "posts/2021-06-05-predicting-difficulty-new-york-times-crossword-puzzles.html",
    "title": "Predicting difficulty in New York Times Crossword puzzles",
    "section": "",
    "text": "As part of the Erdős Institue May 2021 Data Science Boot Camp, my group investigated patterns in 27 years worth of New York Times Crossword puzzle data. My group consisted of Caitlin Carpenter and Jonathan Viereck, and the work described here is a shared effort among the three of us.\nWe extracted a number of features from the raw puzzle data, such as clue length, hint length, density of the puzzle grid, and so one. Our goal was to build a model that can predict what day of the week a puzzle falls on, because (at least for the NY Times) different puzzle difficulties correspond to different days of the week.\nOne of the highest accuracy models is a classifier based on a tf-idf vectorization of the puzzle data. Using a tf-idf score on the puzzle data means that words unique to certain days of the week should be weighted higher than words common to all puzzles overall, so it’s like to pick up if certain topics or keywords are used in “harder” vs. “easier” puzzles. The confusion matrix for this model is shown below. Each axis is a possible label, and this matrix shows both how accurately each label is predicted, and what other lables a category is incorrectly classified as.\n\nMondays and Sundays are very easily classified. A perfect classifier would have a solid line of blocks from top-left to bottom-right. This image shows that other days of the week, while less accurately classified, are often confused for adjacent days of the week. This is likely because those puzzles are quite similar to the adjacent days. (For example, Friday and Saturday look to be very similar.) Even though the overall accuracy hovers around 50%, choosing a day simply by chance would give around a 14% accuracy (1 over 7).\nThe full project is available here."
  },
  {
    "objectID": "posts.html",
    "href": "posts.html",
    "title": "Posts",
    "section": "",
    "text": "Exhaustive list of all ISO-morphic languages (languages whose name equals its ISO 639-3 code)\n\n\n\nfun\n\n\n\n\n\n\n\n\n\nMay 3, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nHow to make a vowel chart using matplotlib and python\n\n\n\nphonetics\n\nphonology\n\ntutorial\n\npython\n\n\n\n\n\n\n\n\n\nJun 3, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nHow to send a Canvas announcement from your email app\n\n\n\ntutorial\n\nteaching\n\n\n\n\n\n\n\n\n\nDec 27, 2020\n\n\n\n\n\n\n\n\n\n\n\n\nHow to write a phonological rule in Microsoft Word\n\n\n\nphonology\n\ntutorial\n\n\n\n\n\n\n\n\n\nApr 27, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nInstantly making PDFs with Graphviz from Markdown files in VSCode\n\n\n\nteaching\n\npython\n\n\n\n\n\n\n\n\n\nJun 16, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nPredicting difficulty in New York Times Crossword puzzles\n\n\n\npython\n\nfun\n\n\n\n\n\n\n\n\n\nJun 5, 2021\n\n\n\n\n\n\n\n\n\n\n\n\nTyping IPA symbols on your computer\n\n\n\nphonetics\n\nphonology\n\ntutorial\n\n\n\n\n\n\n\n\n\nMar 7, 2020\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Research",
    "section": "",
    "text": "What is the range of ways that two theories of phonological representations can differ in their logical power/expressivity? Despite the results that many representations are very close in their computational power, there are still differences among them in how they encode information relevant for their respective grammatical frameworks: what contrasts are encoded, what natural classes are predicted, and so on. This research program builds on the purely logical approach using mathematical logic and finite model theory and incorporates additional modes of comparisons across these linguistically relevant domains. The result is an overall more informative comparison of theories that includes both results for expressivity and framework-specific properties.\n\n\n\nJardine, Adam, Nick Danis, and Luca Iacoponi. 2021. A formal investigation of Q-Theory in comparison to Autosegmental Representations. Linguistic Inquiry 52.2. [doi, lingbuzz]\nDanis, Nick. 2025. “Logical transductions are not sufficient for notational equivalence,” In Gérard Avelino, Merlin Balihaxi, Quartz Colvin, Vincent Czarnecki, Hyunjung Joo, Chenli Wang, Utku Zobarlar, Adam Jardine and Adam McCollum (eds.), Proceedings of the 2023 and 2024 Annual Meetings on Phonology (Supplemental). [doi]\nDanis, Nick and Adam Jardine. 2019. “Q-Theory Representations are Logically Equivalent to Autosegmental Representations,” Proceedings of the Society for Computation in Linguistics: Vol. 2 , Article 5. [doi]\nDanis, Nick. 2026. Representing phonology in the formal comparison of phonological representations. Keynote speaker, Workshop on The Role of Representation in Computational Phonology. OCP23 satellite workshop. University of Cambridge, January 13, 2026.\nDanis, Nick. 2024. Comparing representations: Towards a strong generative capacity for phonology. Invited speaker, RULing 2024, Rutgers University, May 3, 2024. [python supplement]"
  },
  {
    "objectID": "research.html#theory-comparison",
    "href": "research.html#theory-comparison",
    "title": "Research",
    "section": "",
    "text": "What is the range of ways that two theories of phonological representations can differ in their logical power/expressivity? Despite the results that many representations are very close in their computational power, there are still differences among them in how they encode information relevant for their respective grammatical frameworks: what contrasts are encoded, what natural classes are predicted, and so on. This research program builds on the purely logical approach using mathematical logic and finite model theory and incorporates additional modes of comparisons across these linguistically relevant domains. The result is an overall more informative comparison of theories that includes both results for expressivity and framework-specific properties.\n\n\n\nJardine, Adam, Nick Danis, and Luca Iacoponi. 2021. A formal investigation of Q-Theory in comparison to Autosegmental Representations. Linguistic Inquiry 52.2. [doi, lingbuzz]\nDanis, Nick. 2025. “Logical transductions are not sufficient for notational equivalence,” In Gérard Avelino, Merlin Balihaxi, Quartz Colvin, Vincent Czarnecki, Hyunjung Joo, Chenli Wang, Utku Zobarlar, Adam Jardine and Adam McCollum (eds.), Proceedings of the 2023 and 2024 Annual Meetings on Phonology (Supplemental). [doi]\nDanis, Nick and Adam Jardine. 2019. “Q-Theory Representations are Logically Equivalent to Autosegmental Representations,” Proceedings of the Society for Computation in Linguistics: Vol. 2 , Article 5. [doi]\nDanis, Nick. 2026. Representing phonology in the formal comparison of phonological representations. Keynote speaker, Workshop on The Role of Representation in Computational Phonology. OCP23 satellite workshop. University of Cambridge, January 13, 2026.\nDanis, Nick. 2024. Comparing representations: Towards a strong generative capacity for phonology. Invited speaker, RULing 2024, Rutgers University, May 3, 2024. [python supplement]"
  },
  {
    "objectID": "research.html#complex-place",
    "href": "research.html#complex-place",
    "title": "Research",
    "section": "Complex place",
    "text": "Complex place\n\nRepresentative work\n\nDanis, Nick. 2019. Long-distance major place harmony. Phonology 36.4. 573-604. [doi, lingbuzz, ROA-1365]\nDanis, Nick. 2017. Markedness and Complex Stops: Evidence from Simplification Processes. In Shigeki Kaji (ed.), Proceedings of the 8th World Congress of African Languages Kyoto 2015, 25–43. Tokyo University of Foreign Studies: Research Institute for Languages and Cultures of Asia and Africa. [ROA-1303]\nDanis, Nick. 2017. Complex place and place identity. PhD Dissertation, Rutgers University. Chair: Akin Akinlabi. [doi, lingbuzz, ROA-1324]\nDanis, Nick. 2014. Deriving Interactions of Complex Stops. Ms., Rutgers University. Second Qualifying Paper. Committee: Alan Prince (Chair), Bruce Tesar, Akin Akinlabi. [ROA-1220, ROA-1221 (OTWorkplace Supplement)]"
  },
  {
    "objectID": "syllabi/ling148-fa2020-syllabus.html",
    "href": "syllabi/ling148-fa2020-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling148-fa2024-syllabus.html",
    "href": "syllabi/ling148-fa2024-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling148-sp2024-syllabus.html",
    "href": "syllabi/ling148-sp2024-syllabus.html",
    "title": "LING 148 The Linguistics of Constructed Languages",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-fa2019-syllabus.html",
    "href": "syllabi/ling170d-fa2019-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-fa2022-syllabus.html",
    "href": "syllabi/ling170d-fa2022-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-sp2019-syllabus.html",
    "href": "syllabi/ling170d-sp2019-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-sp2023-syllabus.html",
    "href": "syllabi/ling170d-sp2023-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling170d-sp2025-syllabus.html",
    "href": "syllabi/ling170d-sp2025-syllabus.html",
    "title": "LING 170D Introduction to Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling312-sp2019-syllabus.html",
    "href": "syllabi/ling312-sp2019-syllabus.html",
    "title": "LING 312 Phonetics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling313-fa2019-syllabus.html",
    "href": "syllabi/ling313-fa2019-syllabus.html",
    "title": "LING 313 Phonological Analysis",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling313-fa2021-syllabus.html",
    "href": "syllabi/ling313-fa2021-syllabus.html",
    "title": "LING 313 Phonological Analysis",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling313-fa2024-syllabus.html",
    "href": "syllabi/ling313-fa2024-syllabus.html",
    "title": "LING 313 Phonological Analysis",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2020-syllabus.html",
    "href": "syllabi/ling317-sp2020-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2023-syllabus.html",
    "href": "syllabi/ling317-sp2023-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling317-sp2025-syllabus.html",
    "href": "syllabi/ling317-sp2025-syllabus.html",
    "title": "LING 317 Introduction to Computational Linguistics",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling4250-sp2026-syllabus.html",
    "href": "syllabi/ling4250-sp2026-syllabus.html",
    "title": "LING 4250 Computation and Learnability in Linguistic Theory",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling427-fa2022-syllabus.html",
    "href": "syllabi/ling427-fa2022-syllabus.html",
    "title": "LING 427 Computation and Learnability in Linguistic Theory",
    "section": "",
    "text": "Download PDF file.Download"
  },
  {
    "objectID": "syllabi/ling495-fa2023-syllabus.html",
    "href": "syllabi/ling495-fa2023-syllabus.html",
    "title": "LING 495 Senior Seminar in Optimality Theory",
    "section": "",
    "text": "Download PDF file.Download"
  }
]